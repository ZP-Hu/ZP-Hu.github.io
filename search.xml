<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试题整理</title>
      <link href="/2020/03/08/%E9%9D%A2%E8%AF%95/"/>
      <url>/2020/03/08/%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="面试题整理"><a href="#面试题整理" class="headerlink" title="面试题整理"></a>面试题整理</h2><h3 id="1-什么是jvm内存泄漏，举例？"><a href="#1-什么是jvm内存泄漏，举例？" class="headerlink" title="1.什么是jvm内存泄漏，举例？"></a>1.什么是jvm内存泄漏，举例？</h3><pre class=" language-java"><code class="language-java">   一个对象或者是一个变量没有被引用时，不能被gc回收，或者说当前对象持有短对象的引用时，就容易出现内存的泄漏。   比如数据库连接（DataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span>）<span class="token punctuation">,</span>IO操作没有手动释放连接资源。</code></pre><h3 id="2-equals-和-的区别？"><a href="#2-equals-和-的区别？" class="headerlink" title="2.equals()和==的区别？"></a>2.equals()和==的区别？</h3><pre class=" language-java"><code class="language-java">   在没有重写equals（）方法之前，他俩没有任何区别，因为object的equals方法就是<span class="token operator">==</span>实现的；   <span class="token operator">==</span>比较的是对象的引用地址，当我们重写equals方法之后，比较的是对象的内容，比如String，用equals比较的就是字符串的内容。</code></pre><h3 id="3-实现clone和equals方法时需要注意什么？"><a href="#3-实现clone和equals方法时需要注意什么？" class="headerlink" title="3.实现clone和equals方法时需要注意什么？"></a>3.实现clone和equals方法时需要注意什么？</h3><pre class=" language-java"><code class="language-java">   实现clone需要先实现cloneable接口，如果被克隆的对象都是基本数据类型，就用浅克隆，如果包含引用数据类型，就用深克隆；   浅克隆：复制后对象的属性和原来对象完全相同，并且如果是非基本数据类型，他们会指向同一个内存地址；   深克隆：复制后的对象和原对象指向不同的内存地址。   实现equals方法要实现hashCode方法，先比较两个对象的hashcode是否相同，如果相同，再通过equals进行比较。两个对象相等，他们的hashcode一定相同。</code></pre><h3 id="4-volatile"><a href="#4-volatile" class="headerlink" title="4.volatile"></a>4.volatile</h3><pre class=" language-java"><code class="language-java">   解决的是多线程间共享变量的可见性问题，但是不能保证原子性；   有这个关键字修饰的变量被一个线程修改时会直接同步更新到主内存中，其他线程也会直接从主内存读取更新后的值；   i<span class="token operator">++</span>和<span class="token operator">++</span>i不具备原子性，线程是不安全的，需要加同步锁保证一个线程执行完，其他线程才能执行。</code></pre><h3 id="5-BlockingQueue相比普通的queue最大的区别是什么？"><a href="#5-BlockingQueue相比普通的queue最大的区别是什么？" class="headerlink" title="5.BlockingQueue相比普通的queue最大的区别是什么？"></a>5.BlockingQueue相比普通的queue最大的区别是什么？</h3><pre class=" language-java"><code class="language-java">   当队列为空时从队列中获取元素的线程会阻塞，当队列已满时向队列添加元素的线程会阻塞。</code></pre><h3 id="6-Thread-sleep-可能抛出的InterruptedException代表什么？如何处理？"><a href="#6-Thread-sleep-可能抛出的InterruptedException代表什么？如何处理？" class="headerlink" title="6.Thread.sleep()可能抛出的InterruptedException代表什么？如何处理？"></a>6.Thread.sleep()可能抛出的InterruptedException代表什么？如何处理？</h3><pre class=" language-java"><code class="language-java">   代表一个处于休眠状态的线程被设置为打断，当出现这个异常的时候，说明该线程在休眠状态时其他线程调用了打断的方法，给他打上了一个中断的标识；   处理的话看业务需求，可以进行异常的捕获对线程进行恢复或者其他操作。</code></pre><h3 id="7-反转数组"><a href="#7-反转数组" class="headerlink" title="7.反转数组"></a>7.反转数组</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">char</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>data   <span class="token keyword">char</span> x<span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span>lenth<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       x <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>data<span class="token punctuation">.</span>lenth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        data<span class="token punctuation">[</span>data<span class="token punctuation">.</span>lenth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   x <span class="token operator">=</span> null<span class="token punctuation">;</span>  </code></pre><h3 id="8-redirect和forword区别"><a href="#8-redirect和forword区别" class="headerlink" title="8.redirect和forword区别"></a>8.redirect和forword区别</h3><pre class=" language-java"><code class="language-java">   转发是一次请求，只能在一个服务器内部存在，重定向是两次请求，可以在多个服务器之间进行操作。</code></pre><h3 id="9-使用注解声明Bean，如何指定Bean的加载顺序？"><a href="#9-使用注解声明Bean，如何指定Bean的加载顺序？" class="headerlink" title="9.使用注解声明Bean，如何指定Bean的加载顺序？"></a>9.使用注解声明Bean，如何指定Bean的加载顺序？</h3><pre class=" language-java"><code class="language-java">   通过Order注解中的value值设置Bean的加载优先级，数值越低，优先级越高。</code></pre><h3 id="10-多个同类型的Bean-使用注解注入时如何指定？"><a href="#10-多个同类型的Bean-使用注解注入时如何指定？" class="headerlink" title="10.多个同类型的Bean,使用注解注入时如何指定？"></a>10.多个同类型的Bean,使用注解注入时如何指定？</h3><pre class=" language-java"><code class="language-java">   使用<span class="token annotation punctuation">@Autowired</span>注解时，会自动按照类型注入，类型匹配多个时，可以和<span class="token annotation punctuation">@Qualifire</span>注解结合使用，根据被注入变量的变量名进行匹配。   或者使用<span class="token annotation punctuation">@Resource</span>注解，直接指定变量名进行注入。</code></pre><h3 id="11-XML映射中，SQL语句的两种参数注入方法：-和-的区别？"><a href="#11-XML映射中，SQL语句的两种参数注入方法：-和-的区别？" class="headerlink" title="11.XML映射中，SQL语句的两种参数注入方法：#和$的区别？"></a>11.XML映射中，SQL语句的两种参数注入方法：#和$的区别？</h3><pre class=" language-java"><code class="language-java">   #是预编译，表示一个占位符，参数会转为？<span class="token punctuation">,</span>可以有效防止sql注入；   $是sql语句的直接拼接，不能防止sql注入问题。</code></pre><h3 id="12-XML中，如何使用like进行模糊查询？"><a href="#12-XML中，如何使用like进行模糊查询？" class="headerlink" title="12.XML中，如何使用like进行模糊查询？"></a>12.XML中，如何使用like进行模糊查询？</h3><pre class=" language-mysql"><code class="language-mysql">   like "%"#{}"%"   like '%${}%'   like CONCAT('%','${}','%')</code></pre><h3 id="13-redis中，如何使key对应的值5s后失效？"><a href="#13-redis中，如何使key对应的值5s后失效？" class="headerlink" title="13.redis中，如何使key对应的值5s后失效？"></a>13.redis中，如何使key对应的值5s后失效？</h3><pre class=" language-java"><code class="language-java">   expire key <span class="token number">5</span>   persist key 是移除指定key的过期时间</code></pre><h3 id="14-scan和keys命令的区别？"><a href="#14-scan和keys命令的区别？" class="headerlink" title="14.scan和keys命令的区别？"></a>14.scan和keys命令的区别？</h3><pre class=" language-java"><code class="language-java">   keys是一次返回结果，scan是多次迭代返回。</code></pre><h3 id="15-redis如何开启和执行事务？"><a href="#15-redis如何开启和执行事务？" class="headerlink" title="15.redis如何开启和执行事务？"></a>15.redis如何开启和执行事务？</h3><pre class=" language-java"><code class="language-java">   multi命令开启事务，exec提交事务，discard回滚事务。</code></pre><h3 id="16-redis使用管道（Pipeline）有什么好处？"><a href="#16-redis使用管道（Pipeline）有什么好处？" class="headerlink" title="16.redis使用管道（Pipeline）有什么好处？"></a>16.redis使用管道（Pipeline）有什么好处？</h3><pre class=" language-java"><code class="language-java">   可以在处理大量数据时将多次操作进行一次性处理，可以减少服务器端的压力，也能减少时间的消耗。</code></pre><h3 id="17-表中有A-B-C-三列-用SQL-语句实现：当A-列大于B-列时选择A-列否则选择B-列，当B列大于C列时-选择B-列否则选择C-列？"><a href="#17-表中有A-B-C-三列-用SQL-语句实现：当A-列大于B-列时选择A-列否则选择B-列，当B列大于C列时-选择B-列否则选择C-列？" class="headerlink" title="17.表中有A B C 三列,用SQL 语句实现：当A 列大于B 列时选择A 列否则选择B 列，当B列大于C列时 选择B 列否则选择C 列？"></a>17.表中有A B C 三列,用SQL 语句实现：当A 列大于B 列时选择A 列否则选择B 列，当B列大于C列时 选择B 列否则选择C 列？</h3><pre class=" language-mysql"><code class="language-mysql">select (case when A > B then A else B end),(case B > C then B else C end) from table;</code></pre><h3 id="18-数据库索引分类？"><a href="#18-数据库索引分类？" class="headerlink" title="18.数据库索引分类？"></a>18.数据库索引分类？</h3><pre class=" language-mysql"><code class="language-mysql">    单值索引：一个索引代表一个列，一张表可以包含多个单值索引；    唯一索引：索引列中的值必须唯一，允许有空值；    复合索引：一个索引包含多个列。    create index idx_table_name on user(name);</code></pre><h3 id="19-存储过程和存储函数的区别？"><a href="#19-存储过程和存储函数的区别？" class="headerlink" title="19.存储过程和存储函数的区别？"></a>19.存储过程和存储函数的区别？</h3><pre class=" language-java"><code class="language-java">    存储过程没有返回值，存储函数有返回值。    create procedure <span class="token function">pro_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    begin      declare a <span class="token keyword">int</span> <span class="token keyword">default</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>      select a<span class="token punctuation">;</span>    end<span class="token punctuation">;</span></code></pre><h3 id="20-如何修改MySQL语句的分隔符符号？"><a href="#20-如何修改MySQL语句的分隔符符号？" class="headerlink" title="20.如何修改MySQL语句的分隔符符号？"></a>20.如何修改MySQL语句的分隔符符号？</h3><pre class=" language-mysql"><code class="language-mysql">delimiter $</code></pre><h3 id="21-谈谈你对gc的了解？"><a href="#21-谈谈你对gc的了解？" class="headerlink" title="21.谈谈你对gc的了解？"></a>21.谈谈你对gc的了解？</h3><pre class=" language-java"><code class="language-java">    首先，知道什么样的对象会被当做垃圾回收，当一个对象不再被别人引用时，垃圾回收器会在空闲的时候    对其进行回收；我们怎么知道垃圾被回收了？可以通过重写object类的finalize方法来验证，因为垃圾在    被回收的时候，回收器会自动调用该方法；最后，如何通知回收器去回收垃圾？通过System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法可以    去通知回收器进行垃圾回收。</code></pre><h3 id="22-gc的常见算法？"><a href="#22-gc的常见算法？" class="headerlink" title="22.gc的常见算法？"></a>22.gc的常见算法？</h3><pre class=" language-java"><code class="language-java">    我了解的判断垃圾对象的算法有两个，引用计数法和可达性分析法，引用计数法就是每个对象都给他设置一个计数器，每次被引用，计数器都加一，反之减一，当计数器为<span class="token number">0</span>的时候就会被当成垃圾回收，但是现在java一般不用他，因为这个算法有一个问题java没有解决，就是对象的循环引用问题，所以现在一般都用可达性分析法，找到一个根节点，然后找他引用的节点，再通过他引用的节点找各自引用的节点，一直找到最后没有引用为止，这样除了从根节点包括根节点往下的所有节点对象，其他都是不可达的，也就是没有被引用的垃圾对象。    对于垃圾回收的算法，我知道的有三个，最开始是标记<span class="token operator">-</span>清除算法，先标记出所有的垃圾对象，最后一起进行回收，但是这个算法不论是标记还是回收效率都不高，第二个是复制算法，将内存区域划分为相等大小的两块，先使用其中一块内存，另一块空着，当这块内存用完了，再将活着的对象复制到空的那块内存区域，然后把用完的那块内存中的所有对象清除，这也有一个缺点，就是内存浪费严重；第三种就是分代收集算法，将堆内存划分为年轻代和老年代，在年轻代中又划分为edon区和两个大小相同的serviver区，在年轻代可以使用复制算法进行垃圾回收，当edon区和一个serviver区被占满的时候，会将存活的对象复制到另一个serviver区，当一个对象在两个serviver区中移动<span class="token number">15</span>次之后就会转移到老年代，在老年代中可以使用标记<span class="token operator">-</span>清除算法，因为这里的回收频率不高。</code></pre><h3 id="23-String-StringBuilder和StringBuffuer的区别？"><a href="#23-String-StringBuilder和StringBuffuer的区别？" class="headerlink" title="23.String,StringBuilder和StringBuffuer的区别？"></a>23.String,StringBuilder和StringBuffuer的区别？</h3><pre class=" language-java"><code class="language-java">    String是不可改变的字符序列<span class="token punctuation">;</span>StringBuilder是可以改变的字符序列；    字符串拼接的时候，string每一次拼接都会创建一个新的对象，底层就是stringBuilder；    StringBuilder和StringBuffuer相比，前者是线程不安全的，所以效率会高一些，后者线程安全，效率会低一些。</code></pre><h3 id="24-如果在业务层拼接sql，使用string类型接收吗？"><a href="#24-如果在业务层拼接sql，使用string类型接收吗？" class="headerlink" title="24.如果在业务层拼接sql，使用string类型接收吗？"></a>24.如果在业务层拼接sql，使用string类型接收吗？</h3><pre class=" language-java"><code class="language-java">   不一定，如果sql语句拼接内容较少的时候，可以用string，但是拼接内容多的时候应该用stringBuilder<span class="token punctuation">;</span></code></pre><h3 id="25-hashMap和hashTable的区别？"><a href="#25-hashMap和hashTable的区别？" class="headerlink" title="25.hashMap和hashTable的区别？"></a>25.hashMap和hashTable的区别？</h3><pre class=" language-java"><code class="language-java">    相同点，他们是都双列集合，键不能重复，值可以重复；    不同点，hashMap是线程不同步的，hashtable是线程同步的；并且hashMap可以存null键和值，hashTable不行。</code></pre><h3 id="26-单例模式中，懒汉式和饿汉式的区别？"><a href="#26-单例模式中，懒汉式和饿汉式的区别？" class="headerlink" title="26.单例模式中，懒汉式和饿汉式的区别？"></a>26.单例模式中，懒汉式和饿汉式的区别？</h3><pre class=" language-java"><code class="language-java">    懒汉式在类加载的时候不进行初始化，当用到的时候才创建对象；    饿汉式是在类创建的时候就已经完成了对象的创建；    懒汉式在不加同步锁的情况下是线程不安全的，饿汉式线程安全；</code></pre><h3 id="27-spring的AOP实现原理？"><a href="#27-spring的AOP实现原理？" class="headerlink" title="27.spring的AOP实现原理？"></a>27.spring的AOP实现原理？</h3><pre class=" language-java"><code class="language-java">    通过动态代理实现的，当被代理类有实现的接口时，使用JDK动态代理方式，如果没有实现接口，则通过cglib动态代理动态的生成被代理类的子类来实现。</code></pre><h3 id="28-spring中，bean的作用域有哪些？"><a href="#28-spring中，bean的作用域有哪些？" class="headerlink" title="28.spring中，bean的作用域有哪些？"></a>28.spring中，bean的作用域有哪些？</h3><pre class=" language-java"><code class="language-java">    SingleTon：单例模式；IOC容器仅创建一个bean实例；    prototype：多例模式；IOC容器创建多个bean实例，每次返回的都是新的实例；    request：HTTP请求；每次http请求都会创建一个新的bean实例；    session：HTTPsession；同一个session共享一个bean实例；不同session使用不同bean实例。</code></pre><h3 id="29-springMvc和Struts2的区别？"><a href="#29-springMvc和Struts2的区别？" class="headerlink" title="29.springMvc和Struts2的区别？"></a>29.springMvc和Struts2的区别？</h3><pre class=" language-java"><code class="language-java">     他们的底层都离不开servletAPI<span class="token punctuation">,</span>但是前者入口是servlet，后者入口是filter，前者是基于方法设计的，后者是基于类设计。</code></pre><h3 id="30-电商项目中哪些地方用到了多线程？"><a href="#30-电商项目中哪些地方用到了多线程？" class="headerlink" title="30.电商项目中哪些地方用到了多线程？"></a>30.电商项目中哪些地方用到了多线程？</h3><pre class=" language-java"><code class="language-java">    我负责的商品管理后台这部分，对商品品牌的修改采用了多线程方式实现，还有同步商品信息的时候，有多个表格都需要修改商品信息。</code></pre><h3 id="31-springCloud的6大组成部分？"><a href="#31-springCloud的6大组成部分？" class="headerlink" title="31.springCloud的6大组成部分？"></a>31.springCloud的6大组成部分？</h3><pre class=" language-java"><code class="language-java">    Eureka注册中心，保证各个微服务互相可见；    Feign远程调用；    Zuul网关；    Hystrix熔断器，某个微服务挂掉，保证调用链上的其他微服务正常运行；    Cloud Config云配置中心；保证一个项目只有一个配置文件；    Cloud Bus消息总线，实现不停止服务的情况下更新配置文件。</code></pre><h3 id="32-解释一下什么是倒排索引？"><a href="#32-解释一下什么是倒排索引？" class="headerlink" title="32.解释一下什么是倒排索引？"></a>32.解释一下什么是倒排索引？</h3><pre class=" language-java"><code class="language-java">    就是建立文档关键词与文档id之间的映射关系，通过关键词找到对应的文档id，再通过id找到相应的文档。</code></pre><h3 id="33-什么是jwt"><a href="#33-什么是jwt" class="headerlink" title="33.什么是jwt?"></a>33.什么是jwt?</h3><pre class=" language-java"><code class="language-java">    json web token<span class="token punctuation">,</span>是基于json的用户身份认证规范；    包含三个部分，头部header，载荷payLoad，签名signature；    主要用在分布式站点的单点登录场景；    签名就是将头部和载荷信息进行加密，防止用户访问服务时恶意篡改用户信息；</code></pre><h3 id="34-rabbitMQ"><a href="#34-rabbitMQ" class="headerlink" title="34.rabbitMQ"></a>34.rabbitMQ</h3><pre class=" language-java"><code class="language-java">    主要是生产者与消费者模式，简单模式是一个生产者，一个队列，一个消费者，生产者发送消息，消费者等待消费；    然后是一个生产者，一个队列，多个消费者绑定到这个队列，同时对所有消息进行消费；    然后是一个生产者，一个交换机，多个队列，多个消费者，消息由交换机来决定交给哪些队列，交换机有三种类型，fanout<span class="token operator">:</span>广播，direct：定向，topic：通配符；    广播模式下交换机将消息发送给所有绑定到交换机的队列；    定向模式下交换机将消息发送给符合指定routingKey的队列；    通配符模式下交换机将消息发送给符合routingPattern的队列；</code></pre><h3 id="35-springIOC底层？"><a href="#35-springIOC底层？" class="headerlink" title="35.springIOC底层？"></a>35.springIOC底层？</h3><pre class=" language-java"><code class="language-java">    IOC就是控制反转，将创建对象的权利交给spring容器，当我们需要使用该对象的时候去容器中获取就行；    他的底层是通过工厂模式<span class="token operator">+</span>反射<span class="token operator">+</span>配置文件来实现的，创建一个工厂，在工厂中读取配置文件通过反射创建所需对象，    将创建好的对象保存在集合中，map或者list看实际需求，然后对外提供一个从集合中获取对象的方法。</code></pre><h3 id="36-spring实例化bean的方法？"><a href="#36-spring实例化bean的方法？" class="headerlink" title="36.spring实例化bean的方法？"></a>36.spring实例化bean的方法？</h3><pre class=" language-java"><code class="language-java">    方法由三种，第一，通过使用默认的无参构造创建，第二，通过静态工厂的方式创建，利用工厂中的静态方法实例化bean，第三，通过实例化工厂创建，先将工厂实例化到spring容器中，通过工厂的对象调用工厂中的方法创建所需要的对象。</code></pre><h3 id="37-spring的依赖注入？"><a href="#37-spring的依赖注入？" class="headerlink" title="37.spring的依赖注入？"></a>37.spring的依赖注入？</h3><pre class=" language-java"><code class="language-java">    依赖注入就是通过解耦的方式给属性赋值，可以通过构造方法，setter方法，以及p名称空间注入来实现；    构造方法是在xml配置文件中利用<span class="token operator">&lt;</span>constructor<span class="token operator">-</span>arg<span class="token operator">/</span><span class="token operator">></span>标签注入属性；       setter方法是利用<span class="token operator">&lt;</span>property<span class="token operator">/</span><span class="token operator">></span>标签注入属性；    p名称空间也是依赖setter方法注入属性，只不过书写更加简单。复杂属性也是通过<span class="token operator">&lt;</span>property<span class="token operator">/</span><span class="token operator">></span>标签实现。</code></pre><h3 id="38-Eureka失效剔除，服务续约和自我保护？"><a href="#38-Eureka失效剔除，服务续约和自我保护？" class="headerlink" title="38.Eureka失效剔除，服务续约和自我保护？"></a>38.Eureka失效剔除，服务续约和自我保护？</h3><pre class=" language-java"><code class="language-java">    我们的服务在某些时候可能会宕机，不能正常下线，也可能因为内存溢出或者网络故障等原因造成服务无法正常运行，所以eureka<span class="token operator">-</span>server会设置一个定时任务，每隔一段时间，默认时间是60s，会清除服务清单中超时，默认时间是90s<span class="token punctuation">,</span>没有续约的服务；    在eureka中有一个心跳机制，服务端会隔一段时间告诉eureka我还活着，防止被从eureka的服务列表中清除；    自我保护就是服务端在维护心跳机制的时候，可能因为网络等原因，造成心跳不稳定，因此eureka<span class="token operator">-</span>server在运行期间会统计在<span class="token number">15</span>分钟之内心跳失败的比例是否低于<span class="token number">85</span><span class="token operator">%</span>，如果存在这种情况，eureka就会暂时将服务保护起来，让他不会被当做失效剔除，但是一旦服务在被保护的时候挂掉，就会出现客户端调用失败的情况，所以客户端应该有相应的容错机制，比如调用失败的时候可以请求重试，或者断路器等设置。</code></pre><h3 id="39-能介绍一下你最近的工作吗？"><a href="#39-能介绍一下你最近的工作吗？" class="headerlink" title="39.能介绍一下你最近的工作吗？"></a>39.能介绍一下你最近的工作吗？</h3><pre class=" language-java"><code class="language-java">     最近做的一个项目是微服务架构的全品类电商网站，使用的主要技术有spring，springMvc<span class="token punctuation">,</span>mybatis<span class="token punctuation">,</span>以及springBoot和springCloud<span class="token punctuation">,</span>数据库用的是MySQL，我主要负责两个模块，一个是后台商品的增删改查以及微服务之间的服务鉴权问题；    在服务鉴权这块有两个方向，一个是用户通过zuul网关作为请求入口，访问其他的微服务的权限问题，还有一个就是微服务调用其他微服务的权限问题。因为我们项目是单点登录模式，所以采用权限中心对登录用户签发JWT，通过token的验证来实现的权限控制；    首先对于用户权限这块，用户的请求正常情况下都是经过zuul网关再进行路由分发的，所以我需要在zuul网关对用户请求路由前就进行权限的验证，这里我是利用zuulFilter来实现的，使用pre类型的过滤器，在run方法中进行具体的权限验证逻辑；从请求头中获取用户的token进行解析，解析成功再从数据库查询对应的访问权限验，证通过就正常路由分发，不通过就返回<span class="token number">401</span>；     有些情况是这样的，一个微服务需要访问另一个微服务，比如权限中心在用户登录之后需要访问用户中心查询用户信息来签发JWT，这时候用户中心就需要判断权限中心是否有访问他的权限，具体实现是在项目启动的时候需要访问其他微服务的服务自动到权限中心获取JWT，然后在访问其他微服务的时候将JWT携带在请求头中，被访问的微服务拦截请求，判断请求头中的JWT身份是否合法。</code></pre><h3 id="40-reids有哪5种数据类型？"><a href="#40-reids有哪5种数据类型？" class="headerlink" title="40.reids有哪5种数据类型？"></a>40.reids有哪5种数据类型？</h3><pre class=" language-java"><code class="language-java">    string       hash        list        set        sortSet</code></pre><h3 id="41-springMvc执行的具体流程？"><a href="#41-springMvc执行的具体流程？" class="headerlink" title="41.springMvc执行的具体流程？"></a>41.springMvc执行的具体流程？</h3><pre class=" language-java"><code class="language-java">   <span class="token number">1</span><span class="token punctuation">.</span>请求到达DispatureServlet中央控制器，中央控制器调用处理器映射器，生成一个处理器对象并返回；   <span class="token number">2</span><span class="token punctuation">.</span>中央控制器调用处理器适配器，经过适配之后调用具体的Controller；   <span class="token number">3</span><span class="token punctuation">.</span>Controller执行完得到ModelAndView，返回给处理器适配器，然后再返回给中央控制器；   <span class="token number">4</span><span class="token punctuation">.</span>中央控制器调用视图解析器对ModelAndView进行解析，得到view；   <span class="token number">5</span><span class="token punctuation">.</span>中央控制器根据解析得到的view进行视图的渲染；   <span class="token number">6</span><span class="token punctuation">.</span>返回给客户端。</code></pre><h3 id="42-TCP和UDP的区别？他们在传输协议的哪一层？"><a href="#42-TCP和UDP的区别？他们在传输协议的哪一层？" class="headerlink" title="42.TCP和UDP的区别？他们在传输协议的哪一层？"></a>42.TCP和UDP的区别？他们在传输协议的哪一层？</h3><pre class=" language-java"><code class="language-java">   TCP是网络安全的，在消息传输的时候有三次握手，消息基本不会丢失，UDP不安全；   他们在传输协议的传输层。   网络层：IP协议   应用层：http</code></pre><h3 id="43-redis一般用在什么地方？"><a href="#43-redis一般用在什么地方？" class="headerlink" title="43.redis一般用在什么地方？"></a>43.redis一般用在什么地方？</h3><pre class=" language-java"><code class="language-java">   当数据库中需要查询的数据不经常发生改变的时候，可以将数据存到redis中，可以极大的提高查询效率；</code></pre><h3 id="44-redis怎么解决多线程的高并发？"><a href="#44-redis怎么解决多线程的高并发？" class="headerlink" title="44.redis怎么解决多线程的高并发？"></a>44.redis怎么解决多线程的高并发？</h3><pre class=" language-java"><code class="language-java">   <span class="token number">1</span><span class="token punctuation">.</span>完全基于内存操作的，加上他特有的数据结构，使得它的访问速度非常快；   <span class="token number">2</span><span class="token punctuation">.</span>单线程模式没有CPU上下文切换带来的开销问题，也不用考虑锁的问题，不存在加锁放锁的操作，也不会有死锁带来的性能消耗；   <span class="token number">3</span><span class="token punctuation">.</span>他使用的多路IO复用技术可以高效的处理多个连接请求，既支持了高并发，同时也减少了网络IO的消耗时间；   <span class="token number">4</span><span class="token punctuation">.</span>内部采用了非阻塞的执行方式，吞吐能力较强；   多路IO复用技术指的是可以使用单个线程高效的处理多个连接请求（尽量减少网络IO的消耗）。</code></pre><h3 id="45-redis是单线程还是多线程？"><a href="#45-redis是单线程还是多线程？" class="headerlink" title="45.redis是单线程还是多线程？"></a>45.redis是单线程还是多线程？</h3><pre class=" language-java"><code class="language-java">   是单线程，多线程的本质就是CPU模拟出来多个线程的情况，这种情况会带来上下文切换的问题；   而redis用单个CPU绑定一块内存的数据，然后对这块内存数据的所有操作都是在一个CPU上完成的，没有上下文切换带来的开销问题。</code></pre><h3 id="46-数据库怎么捕获那些运行效率低的sql语句？"><a href="#46-数据库怎么捕获那些运行效率低的sql语句？" class="headerlink" title="46.数据库怎么捕获那些运行效率低的sql语句？"></a>46.数据库怎么捕获那些运行效率低的sql语句？</h3><pre class=" language-java"><code class="language-java">   通过查看日志文件获取，MySQL数据库一些配置选项可以帮助我们及时捕获；   slow_query_log  设置为ON：可以捕获执行时间超过某一数值的sql语句；   long_query_time <span class="token operator">:</span>当sql语句执行时间超过这一数据，就会被记录到日志文件中；   slow_query_log_file <span class="token operator">:</span>记录日志的文件名；   log_queries_not_using_indexes 设置为ON，可以捕获没有设置索引的sql语句，无关sql执行效率。</code></pre><h3 id="47-char-10-varchar-10-插入a-b-c-d四个字母，char占多少，varchar占多少？"><a href="#47-char-10-varchar-10-插入a-b-c-d四个字母，char占多少，varchar占多少？" class="headerlink" title="47.char(10),varchar(10),插入a,b,c,d四个字母，char占多少，varchar占多少？"></a>47.char(10),varchar(10),插入a,b,c,d四个字母，char占多少，varchar占多少？</h3><pre class=" language-java"><code class="language-java">   首先<span class="token keyword">char</span>的长度是不可变的，而varchar长度可变；   插入四个字母后，<span class="token keyword">char</span>所占长度依然是<span class="token number">10</span>，除了a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d四个字母，剩下的会用空格补齐；   varchar在插入字母后长度会立即变成<span class="token number">4</span>，所以我们在这种情况下取数据的时候，<span class="token keyword">char</span>类型的可以用trim（）函数去掉多余的空格，varchar类型直接取就行。</code></pre><h3 id="48-linux查询日志的方法有哪些？"><a href="#48-linux查询日志的方法有哪些？" class="headerlink" title="48.linux查询日志的方法有哪些？"></a>48.linux查询日志的方法有哪些？</h3><pre class=" language-java"><code class="language-java">   tail<span class="token operator">:</span>  tail <span class="token operator">-</span>fn <span class="token number">100</span> catalina<span class="token punctuation">.</span>out 循环实时查看最后<span class="token number">100</span>行的记录；   head<span class="token operator">:</span>  head <span class="token operator">-</span>n <span class="token number">1000</span> catalina<span class="token punctuation">.</span>out 查询日志文件中的头<span class="token number">10</span>行日志；   cat<span class="token operator">:</span> cat filename 第一行到最后一行连续的显示在荧幕上；   tac<span class="token operator">:</span> 由最后一行到第一行反向显示；   sed<span class="token operator">:</span> 可以查找日志文件特定的一段，也可以根据时间范围查询；</code></pre><h3 id="49-我有一个10G的文件，太大打不开，这种情况怎么办？"><a href="#49-我有一个10G的文件，太大打不开，这种情况怎么办？" class="headerlink" title="49.我有一个10G的文件，太大打不开，这种情况怎么办？"></a>49.我有一个10G的文件，太大打不开，这种情况怎么办？</h3><pre class=" language-java"><code class="language-java">   可以对文件先进行分割，然后再打开；   <span class="token number">1</span><span class="token punctuation">.</span>head <span class="token operator">-</span><span class="token number">10000</span><span class="token operator">/</span>var<span class="token operator">/</span>lib<span class="token operator">/</span>mysql<span class="token operator">/</span>a<span class="token punctuation">.</span>log <span class="token operator">></span> temp<span class="token punctuation">.</span>log  <span class="token operator">:</span>将a<span class="token punctuation">.</span>log文件的前<span class="token number">10000</span>行写入到temp<span class="token punctuation">.</span>log文件中；   <span class="token number">2</span><span class="token punctuation">.</span>tail <span class="token operator">-</span><span class="token number">10000</span><span class="token operator">/</span>var<span class="token operator">/</span>lib<span class="token operator">/</span>mysql<span class="token operator">/</span>a<span class="token punctuation">.</span>log <span class="token operator">></span> temp<span class="token punctuation">.</span>log  <span class="token operator">:</span>将a<span class="token punctuation">.</span>log文件的后<span class="token number">10000</span>行写入到temp<span class="token punctuation">.</span>log文件中；   <span class="token number">3</span><span class="token punctuation">.</span>sed <span class="token operator">-</span>n<span class="token string">'10,10000p'</span><span class="token operator">/</span>var<span class="token operator">/</span>lib<span class="token operator">/</span>mysql<span class="token operator">/</span>a<span class="token punctuation">.</span>log <span class="token operator">></span> temp<span class="token punctuation">.</span>log  <span class="token operator">:</span>将a<span class="token punctuation">.</span>log文件的<span class="token number">10</span><span class="token operator">-</span><span class="token number">10000</span>行写入到temp<span class="token punctuation">.</span>log文件中；</code></pre><h3 id="50-写一个掷色子的游戏，连续投掷直到得到6点的结果停止，打印总计投掷的次数？"><a href="#50-写一个掷色子的游戏，连续投掷直到得到6点的结果停止，打印总计投掷的次数？" class="headerlink" title="50.写一个掷色子的游戏，连续投掷直到得到6点的结果停止，打印总计投掷的次数？"></a>50.写一个掷色子的游戏，连续投掷直到得到6点的结果停止，打印总计投掷的次数？</h3><pre class=" language-java"><code class="language-java">       <span class="token comment" spellcheck="true">//初始化计数器</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//死循环掷色子</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//生成随机数</span>            Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//在1-6范围</span>            <span class="token keyword">int</span> num <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//每次投掷计数器+1</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num = "</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"count = "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>  </code></pre><h3 id="52-什么是微服务？"><a href="#52-什么是微服务？" class="headerlink" title="52. 什么是微服务？"></a>52. 什么是微服务？</h3><pre class=" language-java"><code class="language-java">    微服务就是把一个完整的项目可以拆分成一个个细小的业务单元，可以按照不同的业务功能来划分成一个个可以独立运行的小型服务；    微服务之间可以相互独立的运行，甚至可以使用不同的语言来编写，也可以使用不同的数据存储技术，一些微服务也可以提供自己的API给其他微服务调用，当他们整合到一起的时候就是一个完整的项目了。</code></pre><h3 id="53-什么是restFul风格？"><a href="#53-什么是restFul风格？" class="headerlink" title="53. 什么是restFul风格？"></a>53. 什么是restFul风格？</h3><pre class=" language-java"><code class="language-java">    restFul是软件API接口的一种设计风格，因为现在前后端分离的架构越来越流行，所以前端和后台之间的交互也越来越重要，而restFul风格就让我们的web接口变得更加统一和规范，具体来说，每一个URI就代表一种资源，比如说访问用户，就是<span class="token operator">/</span>user，访问日志，就是<span class="token operator">/</span>log，客户端通过四个http动词对服务端资源进行操作，常用的get请求获取，post请求添加，put请求修改，delete请求删除，而且也可以在请求路径上传递参数。</code></pre><h3 id="54-springboot-springcloud和微服务的联系与区别？"><a href="#54-springboot-springcloud和微服务的联系与区别？" class="headerlink" title="54.springboot,springcloud和微服务的联系与区别？"></a>54.springboot,springcloud和微服务的联系与区别？</h3><pre class=" language-java"><code class="language-java">     springBoot可以看做一个脚手架，使用他可以快速的创建一个项目，因为他坚持的是约定大于配置的原则，所以创建项目的时候很多配置都不用我们亲自去做了，微服务是一种架构理念，既然是架构，就需要有人来实现，所以springcloud就提供了大量的组件，实现了一站式的微服务解决方案，但是springcloud在开发过程中是依赖于springboot的。</code></pre><h3 id="55-springboot有哪些优点？"><a href="#55-springboot有哪些优点？" class="headerlink" title="55.springboot有哪些优点？"></a>55.springboot有哪些优点？</h3><pre class=" language-java"><code class="language-java">    快速搭建项目，有内置的服务容器，开发部署方便。</code></pre><h3 id="56-springBoot配置文件格式是什么？有什么区别？"><a href="#56-springBoot配置文件格式是什么？有什么区别？" class="headerlink" title="56.springBoot配置文件格式是什么？有什么区别？"></a>56.springBoot配置文件格式是什么？有什么区别？</h3><pre class=" language-java"><code class="language-java">     有一级配置文件和二级配置文件，一级是bootstrap<span class="token punctuation">.</span>yml<span class="token punctuation">,</span>会在项目启动前加载，二级是application<span class="token punctuation">.</span>yml，在项目启动后加载，一级加载后不会加载二级。</code></pre><h3 id="57-springBoot读取配置文件里面的属性有哪几种方式？"><a href="#57-springBoot读取配置文件里面的属性有哪几种方式？" class="headerlink" title="57.springBoot读取配置文件里面的属性有哪几种方式？"></a>57.springBoot读取配置文件里面的属性有哪几种方式？</h3><pre class=" language-java"><code class="language-java">    用的最多的是使用配置类的方式，利用<span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span>注解来实现属性的自动注入；    也可以用<span class="token annotation punctuation">@Value</span>注解和<span class="token annotation punctuation">@Autowired</span>注解获取。</code></pre><h3 id="58-你知道哪些springboot-starter？"><a href="#58-你知道哪些springboot-starter？" class="headerlink" title="58.你知道哪些springboot-starter？"></a>58.你知道哪些springboot-starter？</h3><pre class=" language-java"><code class="language-java">     web启动器，redis，mybatis，通用mapper，amqp</code></pre><h3 id="59-springCloud常用注解？"><a href="#59-springCloud常用注解？" class="headerlink" title="59.springCloud常用注解？"></a>59.springCloud常用注解？</h3><pre class=" language-java"><code class="language-java">    EnableZuulProxy    EnableEurekaServer    FeignClient等  </code></pre><h3 id="60-如何使用springboot快速启动一个ssm项目？"><a href="#60-如何使用springboot快速启动一个ssm项目？" class="headerlink" title="60.如何使用springboot快速启动一个ssm项目？"></a>60.如何使用springboot快速启动一个ssm项目？</h3><pre class=" language-java"><code class="language-java">    <span class="token number">1</span><span class="token punctuation">.</span>让maven项目继承一个父项目 spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>parent<span class="token punctuation">,</span>表名这是一个springboot项目；    <span class="token number">2</span><span class="token punctuation">.</span>配置springMvc<span class="token punctuation">,</span>也就是引入spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>web<span class="token punctuation">;</span>    <span class="token number">3</span><span class="token punctuation">.</span>配置mybatis，引入mybatis<span class="token operator">-</span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token punctuation">;</span>    <span class="token number">4</span><span class="token punctuation">.</span>在yml配置文件中配置数据源相关，以及mapper<span class="token punctuation">.</span>xml文件的扫描地址；    <span class="token number">5</span><span class="token punctuation">.</span>添加启动类，<span class="token annotation punctuation">@SpringBootApplication</span>注解，通过main方法启动。</code></pre><h3 id="61-介绍一下项目从拿到需求到开始开发的流程？"><a href="#61-介绍一下项目从拿到需求到开始开发的流程？" class="headerlink" title="61.介绍一下项目从拿到需求到开始开发的流程？"></a>61.介绍一下项目从拿到需求到开始开发的流程？</h3><pre class=" language-java"><code class="language-java">    当这个项目确定下来，产品会先设计一个产品原型，我们开发会根据这个产品原型图设计数据模型和业务模块，UI根据产品原型设计产品效果图，我们开发就开始具体的功能的代码编写，前端也是进行前端代码的实现，最后都完成就交给测试对功能分别进行测试，如果有bug我们会改，改完重新测试，测试没有问题就交给运维部署项目，上线。产品<span class="token number">1</span>人，开发<span class="token number">5</span>人，UI1人，前端<span class="token number">4</span>人，测试<span class="token number">1</span>人，运维<span class="token number">1</span>人。</code></pre><h3 id="62-公司git有哪些分支？"><a href="#62-公司git有哪些分支？" class="headerlink" title="62.公司git有哪些分支？"></a>62.公司git有哪些分支？</h3><pre class=" language-java"><code class="language-java">    master生产环境    dev开发环境    test测试环境</code></pre><h3 id="63-并发量大不大？不大的话用springcloud会不会有点浪费？"><a href="#63-并发量大不大？不大的话用springcloud会不会有点浪费？" class="headerlink" title="63.并发量大不大？不大的话用springcloud会不会有点浪费？"></a>63.并发量大不大？不大的话用springcloud会不会有点浪费？</h3><pre class=" language-java"><code class="language-java">    不大，会浪费，微服务架构有很多不同的独立的服务，浪费人去维护不同的微服务，而且微服务架构在无形中也会多出很多其他的微服务，比如监控类的，配置类的，网关类以及注册中心等等。</code></pre><h3 id="64-用户退出怎么注销token？"><a href="#64-用户退出怎么注销token？" class="headerlink" title="64.用户退出怎么注销token？"></a>64.用户退出怎么注销token？</h3><pre class=" language-java"><code class="language-java">    jwt的缺陷就是token生成后无法修改，在用户退出注销token这个问题上，有以下几种解决办法，一个是尽量减小token的有效期，让他尽快失效；    然后可以通过删除客户端cookie的方法让token失效；    最后还有一种就是在服务端对失效的token进行标记，形成一个黑名单，在项目中我们采用的就是黑名单的方式，虽然这个方法违背了无状态特性，但是因为token的有效期本来就很短，所以标记时间也短，因此服务器压力也不会太大。</code></pre><h3 id="65-springcloud组件，谈谈zuul-eureka，feign-hystrix-ribbon的用法？"><a href="#65-springcloud组件，谈谈zuul-eureka，feign-hystrix-ribbon的用法？" class="headerlink" title="65.springcloud组件，谈谈zuul,eureka，feign,hystrix,ribbon的用法？"></a>65.springcloud组件，谈谈zuul,eureka，feign,hystrix,ribbon的用法？</h3><pre class=" language-java"><code class="language-java">    eureka：注册中心，服务的注册与发现，失效剔除，服务续约，自我保护；    ribbon：实现负载均衡，默认是轮询，可以改为随机，已经被eureka集成了，我们可以使用yml配置文件进行配置；    feign：远程调用，他是一种声明式的http客户端，在springcloud中使用feign，可以做到使用http请求调用远程服务的时候和调用本地方法没什么区别；    Hystrix<span class="token operator">:</span> 断路器，一种保护机制；主要解决雪崩问题；有两种手段，线程隔离和服务熔断；他会为每个依赖服务调用分配一个小的线程池，如果线程池满了就会立刻拒绝，默认不排队，加速失败的判定时间，用户的请求也不再是直接访问微服务，而是通过线程池中的空闲线程来访问，如果线程池已满或者请求超时就会进行降级处理，保证用户可以看到一个执行结果，虽然请求可能失败，但是不会被阻塞，而且影响的最多是依赖服务对应的线程池中的资源，对其他服务不会造成影响。    zuul：网关，他的核心功能是过滤和路由；不管是来自客户端的请求还是服务器内部的调用都会经过zuul网关，然后再由他实现鉴权，路由分发等操作。</code></pre><h3 id="66-mysql为什么要优化？你们项目遇到了什么情况会想去优化？"><a href="#66-mysql为什么要优化？你们项目遇到了什么情况会想去优化？" class="headerlink" title="66.mysql为什么要优化？你们项目遇到了什么情况会想去优化？"></a>66.mysql为什么要优化？你们项目遇到了什么情况会想去优化？</h3><pre class=" language-java"><code class="language-java">    数据库出现了瓶颈，访问变慢；    随着应用程序的运行，数据库的数据越来越多，处理时间变长；    数据的读写速度缓慢。</code></pre><h3 id="67-用户请求经过zuul网关之后是直接到达服务器吗？"><a href="#67-用户请求经过zuul网关之后是直接到达服务器吗？" class="headerlink" title="67.用户请求经过zuul网关之后是直接到达服务器吗？"></a>67.用户请求经过zuul网关之后是直接到达服务器吗？</h3><pre class=" language-java"><code class="language-java">    不会，先到达的是我们的代理服务器</code></pre><h3 id="68-说说redis的缓存穿透和缓存雪崩？"><a href="#68-说说redis的缓存穿透和缓存雪崩？" class="headerlink" title="68.说说redis的缓存穿透和缓存雪崩？"></a>68.说说redis的缓存穿透和缓存雪崩？</h3><pre class=" language-java"><code class="language-java">    在正常情况下，我们查询资源会先去缓存中找，如果没有，再去数据库查询，查询到有值，就存入缓存，没有值就不存；这样就可能出现一种情况，每次查询数据库都为空，每次又都不会存入缓存，就会对数据库造成极大的压力，甚至摧毁数据库，就会有可能造成缓存穿透；解决方法：即使数据库查询结果为空，也存入缓存，只不过给缓存设置一个较短的过期时间，比如说<span class="token number">60</span>秒；    缓存雪崩指在某一个时间段，缓存集中过期失效，这样在失效的那段时间会对数据库造成周期性的压力，比如在电商项目中，我们可以按照商品的分类设置不同的有效时长，同一分类也可以加一个随机因子，或者热门商品周期设置长一点，冷门就短一点，尽可能保证缓存周期分散。    缓存击穿，对某个key同一时间进行大并发，集中的访问，在key失效的瞬间，就好像凿了一个洞，直接会访问数据库，在电商项目中，一些爆款商品可能会出现这种情况，我们只要把这些商品缓存周期设置为永久就行。</code></pre><h3 id="69-说说cors？怎么使用？"><a href="#69-说说cors？怎么使用？" class="headerlink" title="69.说说cors？怎么使用？"></a>69.说说cors？怎么使用？</h3><pre class=" language-java"><code class="language-java">    他是解决跨域的一种方式，在请求头中加入一些信息，然后在服务端以此判断是否允许其跨域，然后在响应头中加入一些信息即可。    对于浏览器发出的请求总的来说可以分为两种，简单请求和特殊请求，简单请求就是请求方式为get，post，或者head其中一种，并且http的头信息不能超出一些规定的字段，具体什么字段我没记住，当是简单请求时，会在请求头中加一个origin字段，字段值为指定当前请求是哪个域，也就是协议<span class="token operator">+</span>域名<span class="token operator">+</span>端口，服务端会根据这个值决定是否允许跨域，如果允许，就会在响应头中携带两个值，一个是可以接受的域，一个是是否允许携带cookie，这个值设置为<span class="token boolean">true</span>。而特殊请求则是在正式通信之前发出一次预检请求，浏览器先询问服务器，当前网页所在域名是不是在服务器许可的白名单中；使用的话其实springMvc已经帮我们写好了Cors的过滤器，我们只需要写一个配置类，然后注册CorsFilter就可以了。</code></pre><h3 id="70-说说你负责的电商的第一个模块？"><a href="#70-说说你负责的电商的第一个模块？" class="headerlink" title="70.说说你负责的电商的第一个模块？"></a>70.说说你负责的电商的第一个模块？</h3><pre class=" language-java"><code class="language-java">    我主要负责的是后台管理模块中商品的操作，我们这个后台管理系统是使用Vue<span class="token operator">+</span>WebPack<span class="token operator">+</span>Vue<span class="token operator">-</span>Route<span class="token operator">+</span>Vuetify构建的单页应用，整个项目只有一个html，通过vue<span class="token operator">-</span>route根据路由规则来切换展示的页面，达到动态切换的效果，然后通过nginx反向代理，与前台项目使用一个微服务集群，我们是使用的axios来发送ajax请求，由于我们后台域名和后端域名不一致，ajax请求默认情况下是不允许跨域的，所以这里就出现跨域请求的问题，我们是使用cors来解决的跨域问题；    关于我们表结构的设计包括了品牌，分类，商品以及规格参数，对于商品的话，我们划分了spu和sku两个概念，spu用来保存一组具有共同属性的商品集，而sku保存的是具体的商品，他们每一个都有自己特有的属性，举个例子，书是一个具有公共属性的商品集，而J<span class="token punctuation">.</span>K罗琳写的哈利波特就是一个具体的商品，可以看做是一个sku。因为在spu中需要保存的信息太多，所以我们对spu的表进行了垂直拆分，拆分出一张spu<span class="token operator">-</span>detail，商品详情表用来保存通用的规格参数等数据量较大并且不经常查询的数据，同时用一张库存表sku来表示那些具体产品的库存量，品牌和分类，一个品牌可以属于多个分类，一个分类下也会有多个品牌，他们是多对多的关系，所以用一张中间表来表示他俩的具体关系；    规格参数的话，我们用一张规格参数组的表来保存对规格参数的分类，保存具体的规格参数的名称，一个商品的分类下有多个规格参数组，每个规格参数组又有不同的规格参数，并且在设计规格参数表的时候还加了其他一些字段，分别用来表示该规格参数是否是数值类型，是否可以用来搜索，是否是通用的规格参数，如果是通用规格参数，就去spu表中通用规格参数字段查询他的值，不是就去spu表中特有规格参数字段获取，这些字段是对后期做搜索和数据展示有帮助的。由于商品种类非常多，所以商品的品牌相关数据量比较大，因此我们考虑使用redis作为缓存，使用redis中的hash结构，最外层key保存商家id，内层key保存品牌id，value保存品牌信息，我们设置redis有效期为30min，先去redis中查询，如果没有就去数据库，查到数据再保存到redis中。   </code></pre><h3 id="71-说说什么是springcloud？"><a href="#71-说说什么是springcloud？" class="headerlink" title="71.说说什么是springcloud？"></a>71.说说什么是springcloud？</h3><pre class=" language-java"><code class="language-java">    是一个基于Spring Boot实现的服务治理工具包，在微服务架构中用于管理和协调服务的；</code></pre><h3 id="72-你这个电商项目都有哪些服务？"><a href="#72-你这个电商项目都有哪些服务？" class="headerlink" title="72.你这个电商项目都有哪些服务？"></a>72.你这个电商项目都有哪些服务？</h3><pre class=" language-java"><code class="language-java">    网关，注册中心，权限中心，用户中心，商品，文件上传，搜索功能，短信功能，静态页面，购物车，订单</code></pre><h3 id="73-介绍一下你做的这个旅游网站？"><a href="#73-介绍一下你做的这个旅游网站？" class="headerlink" title="73.介绍一下你做的这个旅游网站？"></a>73.介绍一下你做的这个旅游网站？</h3><pre class=" language-java"><code class="language-java">    我们做的这个旅游网站是ssm架构的项目，使用maven管理，数据库使用的MySQL，我主要负责的是旅游线路的部分以及用户收藏模块；对于不同的旅游线路来说，他们具有不同的分类，因此在数据库表的设计上，包括一张旅游路线分类表以及路线表，由于路线表中存储数据较多，因此我们对路线表进行了垂直划分，将路线对应的图片地址单独存储在一张表中，而分类表中只保存分类的类别名称，在查询路线分类信息时出现了一个中文乱码的情况，原因是springmvc在向前端响应字符串时，默认使用的消息转换器的编码是ISO<span class="token operator">-</span><span class="token number">8859</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>我们需要的却是UTF<span class="token operator">-</span><span class="token number">8</span>，所以在springmvc的核心配置文件中配置了一个注解驱动，指定字符串的消息转换器的编码为UTF<span class="token operator">-</span><span class="token number">8</span>来解决这个问题；    对于分类信息来说，内容很少需要改变，为了提高用户体验，所以这里考虑使用redis作为缓存，将分类信息封装到一个list集合中，然后将list集合转为json对象，作为redis中value的值，先去redis中查询，没有值再去数据库查，查到之后再存入redis中；    在路线收藏模块中，当加载路线详情页面时，会携带当前路线id发送请求到后台，我们会先从session中获取用户信息，首先判断该用户是否已经登录，如果没有登录就会显示一个点击收藏的按钮，如果用户已经登录，那么就通过用户id和路线id查询该用户是否已经收藏过该路线，如果收藏过，则前端就不再显示点击收藏按钮；当用户点击收藏按钮的时候，这里会做一个判断，判断用户是否登录，如果登录，将该线路信息添加到数据库的线路收藏表中，并且重新查询收藏次数方便更新到前端页面中，如果没有登录，点击就会跳转到登录页面；并且用户在登录之后，可以查看自己已经收藏的线路信息。</code></pre><h3 id="74-最近看过哪些书？对公司有什么要求？自己未来的规划？"><a href="#74-最近看过哪些书？对公司有什么要求？自己未来的规划？" class="headerlink" title="74.最近看过哪些书？对公司有什么要求？自己未来的规划？"></a>74.最近看过哪些书？对公司有什么要求？自己未来的规划？</h3><pre class=" language-java"><code class="language-java">《spring boot实战》     要求：        <span class="token number">1</span><span class="token punctuation">.</span>希望在入职之后能有技术上的提升，能有机会接触到公司的核心技术；        <span class="token number">2</span><span class="token punctuation">.</span>工作上如果表现突出，希望能有晋升的机会；        <span class="token number">3</span><span class="token punctuation">.</span>希望能有一个良好的工作氛围，工作环境。     规划：        <span class="token number">1</span><span class="token punctuation">.</span>小的规划是先把微服务深入研究明白；        <span class="token number">2</span><span class="token punctuation">.</span>大的规划，也算一个目标吧，在<span class="token number">2</span><span class="token operator">-</span><span class="token number">3</span>年时间尽可能成为一个架构师。</code></pre><h3 id="75-谈谈数据结构？"><a href="#75-谈谈数据结构？" class="headerlink" title="75.谈谈数据结构？"></a>75.谈谈数据结构？</h3><pre class=" language-java"><code class="language-java">    数组，栈，队列，二叉树，平衡二叉树，红黑树    平衡二叉树左右深度差值不能大于<span class="token number">1</span>；    红黑树是一种特殊的平衡二叉树，保证每次插入最多三次旋转就能达到平衡；</code></pre><h3 id="76-为什么不用二叉树作为数据库索引？"><a href="#76-为什么不用二叉树作为数据库索引？" class="headerlink" title="76.为什么不用二叉树作为数据库索引？"></a>76.为什么不用二叉树作为数据库索引？</h3><pre class=" language-java"><code class="language-java">    当数据索引文件很大时，使用二叉树就会需要大量的磁盘IO，效率很低；</code></pre><h3 id="77-B-Tree和B-Tree的区别？"><a href="#77-B-Tree和B-Tree的区别？" class="headerlink" title="77.B-Tree和B+Tree的区别？"></a>77.B-Tree和B+Tree的区别？</h3><pre class=" language-java"><code class="language-java">    B树每个节点除了存储了指向子节点的索引之外，还有一个data区，所以他单一节点存储的索引不会很多，就导致树的高度较高，磁盘IO次数也会较多，而且每个节点都存储了数据，这样每一层都可能会查找到所需要的数据，因此查询性能就不太稳定；    而B<span class="token operator">+</span>树单一节点存储的索引较多，他的空间利用率也比较高，树的高度较低，磁盘IO次数较少，性能较好，并且B<span class="token operator">+</span>Tree所有数据都存储在叶子节点，所有的叶子节点在同一层，查询性能稳定，对于范围查找来说B<span class="token operator">+</span>Tree存储的数据在叶子节点形成了有序的链表结构，方便范围查找。</code></pre><h3 id="78-为什么数据库索引不用红黑树？"><a href="#78-为什么数据库索引不用红黑树？" class="headerlink" title="78.为什么数据库索引不用红黑树？"></a>78.为什么数据库索引不用红黑树？</h3><pre class=" language-java"><code class="language-java">    首先数据库一般存储数据量都比较大，而红黑树在增删元素的时候会频繁的变色与旋转（左旋，右旋），来保证红黑树的性质，会浪费时间，但是在存储数据量比较小的时候，数据完全可以放进内存，不需要进行磁盘的IO，这种情况红黑树的时间复杂度就比B<span class="token operator">+</span>树低了。</code></pre><h3 id="79-sql优化了解吗？"><a href="#79-sql优化了解吗？" class="headerlink" title="79.sql优化了解吗？"></a>79.sql优化了解吗？</h3><pre class=" language-java"><code class="language-java">    一般在项目上线之后，随着运行时间的增加，业务数据量的增多，sql的执行效率对程序的运行效率的影响也会逐渐增大，此时对sql的优化就很必要了；    对于优化方案的话，可以对查询进行优化，尽量避免全表扫描，对where以及order by涉及的列上建立索引；应该注意索引失效的情况；</code></pre><h3 id="80-什么情况下索引失效？"><a href="#80-什么情况下索引失效？" class="headerlink" title="80.什么情况下索引失效？"></a>80.什么情况下索引失效？</h3><pre class=" language-java"><code class="language-java">    where条件使用or连接，除非or连接的每个列都加上索引；    like进行模糊查询，以<span class="token operator">%</span>开头时，索引失效；    复合索引没有使用左列字段；    where中索引列有运算或者索引列使用了函数；    MySQL觉得全表扫描更快的时候。</code></pre><h3 id="81-MySQL为什么要用索引？"><a href="#81-MySQL为什么要用索引？" class="headerlink" title="81.MySQL为什么要用索引？"></a>81.MySQL为什么要用索引？</h3><pre class=" language-java"><code class="language-java">    通俗一点理解，当我们查询数据库表中的数据时，可以把这张表看做一本书，索引就是这本书的目录，如果没有目录，去书中查找    想要的数据的话，就得一页一页的找，但是有了目录，只需要先查找目录，然后直接定位到想要的数据那里；</code></pre><h3 id="82-rabbitmq怎么保证消息不丢失？不重复消费？"><a href="#82-rabbitmq怎么保证消息不丢失？不重复消费？" class="headerlink" title="82.rabbitmq怎么保证消息不丢失？不重复消费？"></a>82.rabbitmq怎么保证消息不丢失？不重复消费？</h3><pre class=" language-java"><code class="language-java">    rabbitmq消息丢失有三种情况，消息在生产者传入时可能会丢失，rabbitmq收到消息但是还没来得及消费就挂掉了，会导致消息丢失，消费者已经接收到消息，但是还没来得急处理就挂掉了，rabbitmq会认为消息已经被消费；    针对生产者，有两种方案，一是开启rabbitmq事务，生产者发送消息成功则提交事务，发送失败回滚事务；但是这种情况下生产者会阻塞等待是否发送成功，太消耗性能会造成吞吐量的下降；第二种方法是使用消费者的confirm模式，发送消息之后，等待mq的ACK，如果没有收到或者收到发送失败的消息，生产者可以尝试重新发送，这是异步执行的，不会阻塞，目前在生产者这块使用的大多是confirm机制；    针对rabbitmq，设置消息持久化到硬盘，首先将队列持久化，在声明队列的时候设置第二个参数为<span class="token boolean">true</span>即可，然后将队列中的消息持久化，在发送消息的时候将deliveryMode设置为<span class="token number">2</span>即可；    针对消费者，可以使用rabbitmq提供的ACK机制，首先关闭rabbitmq的自动ACK，然后在保证处理完这个消息之后在代码里手动调用ACK，确保消息能够执行完。    消息不重复消费可以通过实现接口幂等的方式来实现，比如在消息体中加一个UUID，数据库中设计一张表以这个UUID作为主键，在执行消息内容之前，先判断该UUID是否已经存在，不存在就正常执行，存在说明已经执行过了。</code></pre><h3 id="83-为什么要用mq？哪些场景用到了mq"><a href="#83-为什么要用mq？哪些场景用到了mq" class="headerlink" title="83.为什么要用mq？哪些场景用到了mq?"></a>83.为什么要用mq？哪些场景用到了mq?</h3><pre class=" language-java"><code class="language-java">    我觉得mq的使用起到了一个解耦的作用，比如在项目中用户注册，登录等很多地方都会用到短信功能，正常情况我们是在一个功能中等到短信发送成功才算完成，现在我们可以将发短信拆成一个独立的微服务，通过mq传递消息，这样不论是登录还是注册都只需要将手机号加到消息体中发送给mq即可，相比来说大大提高了代码的执行效率；静态页的生成也可以使用mq，当商品详情页内容发生改变的时候，可以通过mq告诉生成静态页的微服务将原来的删掉，再生成新的静态页。</code></pre><h3 id="84-你觉得分布式开发和集中式相比有什么缺点？"><a href="#84-你觉得分布式开发和集中式相比有什么缺点？" class="headerlink" title="84.你觉得分布式开发和集中式相比有什么缺点？"></a>84.你觉得分布式开发和集中式相比有什么缺点？</h3><pre class=" language-java"><code class="language-java">    和集中式相比，功能之间的调用时接口的调用，需要编写稳定有效的api<span class="token punctuation">;</span>    分布式之间的通信无法直接通知，需要使用消息机制mq<span class="token punctuation">;</span>    集中式开发在项目调试的时候可以使用debug从头到尾进行调试，但是分布式项目需要有效使用日志组件来帮助我们找到问题。</code></pre><h3 id="85-redis分布式锁怎么实现的？"><a href="#85-redis分布式锁怎么实现的？" class="headerlink" title="85.redis分布式锁怎么实现的？"></a>85.redis分布式锁怎么实现的？</h3><pre class=" language-java"><code class="language-java">    首先，为了确保分布式锁可用，我们至少要同时满足以下条件：    <span class="token number">1</span><span class="token punctuation">.</span>互斥性：任意时刻，只有一个客户端能持有锁；    <span class="token number">2</span><span class="token punctuation">.</span>不会发生死锁：即使持有锁的客户端崩溃，也能保证其他客户端能顺利加锁；    <span class="token number">3</span><span class="token punctuation">.</span>加锁解锁必须是一个客户端；    所以实现redis分布式锁，对于加锁操作来说，可以使用redis的客户端jedis进行操作，jedis提供了一个set方法，里面有一个重载方法有<span class="token number">5</span>个参数，分别是key<span class="token punctuation">,</span>value<span class="token punctuation">,</span>nxxx<span class="token punctuation">,</span>expx以及time<span class="token punctuation">;</span>用key作为锁，key是惟一的，requestId作为value值，他的作用是在释放锁的时候确认是同一个客户端，nxxx设置为NX，表示set <span class="token keyword">if</span> not exist<span class="token punctuation">,</span>即当key不存在的时候进行set操作，若存在不做任何操作；第四个参数传PX，表示给这个key加一个过期的设置，过期的时间就是第<span class="token number">5</span>个参数，这样，加锁的操作就完成了，对于释放锁来说，首先需要验证客户端是否是加锁的客户端，验证通过，删除key即可，但是redis不能保证原子性，所以我们使用jedis的eval方法执行lua脚本的方式去保证原子性，从而达到准确释放锁的目的。</code></pre><h3 id="86-feign在远程调用的时候和dubbo的区别？"><a href="#86-feign在远程调用的时候和dubbo的区别？" class="headerlink" title="86.feign在远程调用的时候和dubbo的区别？"></a>86.feign在远程调用的时候和dubbo的区别？</h3><pre class=" language-java"><code class="language-java">    <span class="token number">1</span><span class="token punctuation">.</span>他俩的容错机制不同，dubbo提供了retry，timeout等参数配置以及其他的一些容错策略，而feign只有熔断机制来实现，处理方式不同；    <span class="token number">2</span><span class="token punctuation">.</span>dubbo支持多传输协议，比如http，redis<span class="token punctuation">,</span>dubbo等，非常灵活，而feign组件是基于http传输协议的，是短连接，不适合高并发访问；    短连接是指一次连接只完成一个功能；</code></pre><h3 id="87-feign的底层原理？"><a href="#87-feign的底层原理？" class="headerlink" title="87.feign的底层原理？"></a>87.feign的底层原理？</h3><pre class=" language-java"><code class="language-java">    首先，在接口上加上<span class="token annotation punctuation">@FeignClient</span>注解，然后feign会针对这个接口创建一个动态代理对象，当我们调用这个接口的时候，本质上就是调用feign创建的动态代理对象，然后这个对象会根据接口上<span class="token annotation punctuation">@requestMapping</span>等注解来动态构造出要请求的服务的地址，最后针对这个地址发起请求，解析响应。</code></pre><h3 id="88-项目中哪些地方用到了redis？"><a href="#88-项目中哪些地方用到了redis？" class="headerlink" title="88.项目中哪些地方用到了redis？"></a>88.项目中哪些地方用到了redis？</h3><pre class=" language-java"><code class="language-java">    保存品牌信息；由于商品种类多，因此品牌相关数据量也比较大；    用户退出登录注销token的时候设置黑名单，存放在redis中；为了减小服务器的压力；</code></pre><h3 id="89-hashMap判断重复的原理？"><a href="#89-hashMap判断重复的原理？" class="headerlink" title="89.hashMap判断重复的原理？"></a>89.hashMap判断重复的原理？</h3><pre class=" language-java"><code class="language-java">    首先获取key的hashcode值，再将这个hashcode通过位运算得到一个<span class="token keyword">int</span>类型的值h，然后再用这个值h和hashMap的长度进行逻辑与运算，h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>就会得到一个比数组长度小的正数，这个值就是数组的索引，位运算的目的也是为了使索引分布均匀，然后先判断该索引位上是否有元素，没有的话就直接在该位置插入，如果有，就遍历该位置的链表，判断是否有相同的key<span class="token punctuation">,</span>如果有，就将该key的value值覆盖，如果没有就插入到链表的最后。</code></pre><h3 id="90-ArrayList和linkedList区别？具体为什么？"><a href="#90-ArrayList和linkedList区别？具体为什么？" class="headerlink" title="90.ArrayList和linkedList区别？具体为什么？"></a>90.ArrayList和linkedList区别？具体为什么？</h3><pre class=" language-java"><code class="language-java">    ArrayList底层是数组结构，可以通过索引快速取值，所以查询速度快；而在增删数据的时候，该索引点后面的其他元素都需要进行数据的移动，所以增删速度慢；    LinkedList底层是链表结构，在查询的时候要从头开始遍历，所以查询速度慢，在linkedList中通过上一个元素记录下一个元素节点信息的方式来进行存储，而在增删的时候只需要改变前后两个元素记录的节点信息就可以，所以他增删比较快；     并且ArrayList有一个容量的概念，初始容量为<span class="token number">10</span>，add操作在需要的时候会扩容，但是linkedList没有这个概念。   </code></pre><h3 id="91-redis持久化？"><a href="#91-redis持久化？" class="headerlink" title="91.redis持久化？"></a>91.redis持久化？</h3><pre class=" language-java"><code class="language-java">    RDB和AOF，RDB是redis默认的持久化方案，他在满足一定条件的时候会将数据进行快照保存到硬盘中；    AOF记录的是每一次对服务器写的操作，是把命令保存到硬盘中；当服务器重启的时候会重新执行这些命令来恢复数据；    如果两种方案同时使用，会优先载入AOF文件来恢复数据，因为相对来说，AOF文件保存的数据集比RDB要完整；</code></pre><h3 id="92-synchronized和lock的区别？"><a href="#92-synchronized和lock的区别？" class="headerlink" title="92.synchronized和lock的区别？"></a>92.synchronized和lock的区别？</h3><pre class=" language-java"><code class="language-java">    <span class="token number">1</span><span class="token punctuation">.</span>前者是一个关键字，lock是一个接口；    <span class="token number">2</span><span class="token punctuation">.</span>前者会自动释放锁，执行完同步代码块或者在线程发生异常的时候会自动释放锁，不会发生死锁，lock需要在<span class="token keyword">finally</span>中手动实现锁的释放；    <span class="token number">3</span><span class="token punctuation">.</span>lock是可中断锁，而前者是不可中断的，必须等线程执行完同步代码才能释放锁；    <span class="token number">4</span><span class="token punctuation">.</span>对于要执行的同步代码量较少的情况建议使用前者，</code></pre><h3 id="93-什么是双亲委派机制？有什么作用或好处？"><a href="#93-什么是双亲委派机制？有什么作用或好处？" class="headerlink" title="93.什么是双亲委派机制？有什么作用或好处？"></a>93.什么是双亲委派机制？有什么作用或好处？</h3><pre class=" language-java"><code class="language-java">    针对类加载器的，一个类加载器要加载某个<span class="token punctuation">.</span><span class="token keyword">class</span>文件时，首先会将这个加载任务指派给自己的父加载器，父加载器递归这个操作，如果父加载器没有加载，自己才会去加载这个类。     虚拟机只有在两个类的类名相同，且加载该类的加载器均相同的情况下才会判定是一个类，如果不采用双亲委派机制，则一个类可能会被多个不同的加载器进行加载，这样的话这个类就会被认为是两个不同的类，相互赋值的时候会出现问题。</code></pre><h3 id="94-类加载器分类？"><a href="#94-类加载器分类？" class="headerlink" title="94.类加载器分类？"></a>94.类加载器分类？</h3><pre class=" language-java"><code class="language-java">    启动类加载器；    扩展类加载器；    应用程序类加载器；</code></pre><h3 id="95-了解线程变量副本吗？"><a href="#95-了解线程变量副本吗？" class="headerlink" title="95.了解线程变量副本吗？"></a>95.了解线程变量副本吗？</h3><pre class=" language-java"><code class="language-java">    线程的变量副本也就是通过TreadLocal，为每一个线程维护一个本地变量；他用于线程间的数据隔离，为每一个使用该共享变量的线程提供一个副本，    线程可以在自己的副本中对该变量进行操作，不同的线程之间不会相互影响，在TreadLocal类里边维护着一个map集合，以线程对象作为key，变    量副本作为value值，比如说在spring的Bean的作用域中，单例模式就是采用TreadLocal进行封装，从而实现在多线程中正常工作。</code></pre><h3 id="96-你知道哪些分布式事务的控制方式？"><a href="#96-你知道哪些分布式事务的控制方式？" class="headerlink" title="96.你知道哪些分布式事务的控制方式？"></a>96.你知道哪些分布式事务的控制方式？</h3><pre class=" language-java"><code class="language-java">2PC<span class="token operator">/</span>3PC<span class="token operator">/</span>TCC</code></pre><h3 id="97-arrayList在进行for循环的时候可以进行删除吗？这里会有出现什么异常？"><a href="#97-arrayList在进行for循环的时候可以进行删除吗？这里会有出现什么异常？" class="headerlink" title="97.arrayList在进行for循环的时候可以进行删除吗？这里会有出现什么异常？"></a>97.arrayList在进行for循环的时候可以进行删除吗？这里会有出现什么异常？</h3><pre class=" language-java"><code class="language-java">    如果是普通<span class="token keyword">for</span>循环，倒叙遍历可以删除，正序不行，在循环中一旦删除某个元素，其后面的元素索引就会发生改变，会导致被删除元素后的那个元素遍历不到；如果是增强<span class="token keyword">for</span>循环的话，删除的时候会报ConcurrentModificationException并发修改异常，因为增强<span class="token keyword">for</span>循环相当于是迭代器的一个简写，迭代器的next方法中有一个检查修改次数的方法，而arrayList的remove方法对修改次数有一个自增的操作，所以会出现并发修改异常，解决方法就是不用arrayList的remove方法，改用iterator的remove方法。</code></pre><h3 id="98-TCP三次握手和四次挥手了解吗？"><a href="#98-TCP三次握手和四次挥手了解吗？" class="headerlink" title="98.TCP三次握手和四次挥手了解吗？"></a>98.TCP三次握手和四次挥手了解吗？</h3><pre class=" language-java"><code class="language-java">    三次握手，第一次是在建立连接时，客户端向服务器发送一个syn包，等待服务器确认；    第二次握手是服务器收到这个包，进行确认，同时自己也发送一个包给客户端；    第三次握手是客户端收到服务器发送的包，并且再次向服务器发送一个确认包，当这个包发送完毕，客户端和服务端连接成功，完成三次握手；    四次挥手，第一次客户端发送请求，用来关闭客户端到服务端的数据传送；    第二次，服务端确认客户端的请求；    第三次，服务器发送请求，用来关闭服务端到客户端的数据传送；    第四次，客户端收到请求，连接断开，完成四次挥手。</code></pre><h3 id="99-知道乐观锁和悲观锁吗？"><a href="#99-知道乐观锁和悲观锁吗？" class="headerlink" title="99.知道乐观锁和悲观锁吗？"></a>99.知道乐观锁和悲观锁吗？</h3><pre class=" language-java"><code class="language-java">   乐观锁就是总是往最好的方面去考虑，当一个线程访问一个共享资源的时候，会认为其他线程不会对他进行操作，所以在访问的时候不会加锁，但是在更新的时候会判断一下在此期间别人有没有更新该数据，一般使用CAS算法实现；cas操作就是先判断再替换，在内存中有一个共享变量A，当线程要更新这个值的时候会有一个预期值，和内存中要更新的值A比较，如果相同，就将A替换成B，不同就不会替换；    悲观锁就是当一个线程访问共享资源的时候总会认为别人会修改，所以在操作之前会先上锁，此时别的线程想要访问该资源，只能阻塞等待该线程操作完毕释放锁之后才能访问，效率低，但是安全。</code></pre><h3 id="100-list中的序列如何保证有序？"><a href="#100-list中的序列如何保证有序？" class="headerlink" title="100.list中的序列如何保证有序？"></a>100.list中的序列如何保证有序？</h3><pre class=" language-java"><code class="language-java">    对于ArrayList来说，首先他有一个容量的概念，底层数动态数组，数组是一块连续的空间，在存元素的时候会找到索引，一个接一个的存储，取的时候也是通过遍历一个接一个取出，所以他是有序的；</code></pre><h3 id="101-说说反射？通过反射能拿到什么具体的信息？"><a href="#101-说说反射？通过反射能拿到什么具体的信息？" class="headerlink" title="101.说说反射？通过反射能拿到什么具体的信息？"></a>101.说说反射？通过反射能拿到什么具体的信息？</h3><pre class=" language-java"><code class="language-java">    在运行状态中，可以得到任意一个类的属性和方法，也可以调用任意对象的属性和方法；</code></pre><h3 id="102-用过什么线程池？"><a href="#102-用过什么线程池？" class="headerlink" title="102.用过什么线程池？"></a>102.用过什么线程池？</h3><pre class=" language-java"><code class="language-java">    常用的是定长的线程池，newFixedThreadPool，可以指定线程池中线程的个数，已满的话会进入等待状态；    单线程化的线程池，newSingleThreadExecutor<span class="token punctuation">,</span>只会用唯一的工作线程来执行任务；    可延迟执行的线程池；</code></pre><h3 id="103-什么是红黑树？什么是B-树？"><a href="#103-什么是红黑树？什么是B-树？" class="headerlink" title="103.什么是红黑树？什么是B+树？"></a>103.什么是红黑树？什么是B+树？</h3><pre class=" language-java"><code class="language-java">    红黑树是平衡树的一种，在原始的二叉树中插入数据可能会出现极端的情况，而红黑树就是定义了许多规则尽可能的保证树的平衡，降低树的高度，因为树的查找性能就是取决于树的高度的；    B<span class="token operator">+</span>树是在B树的基础上改造的，他的数据都存储在叶子节点，同时叶子节点之间还加了指针形成链表结构；索引底层用B<span class="token operator">+</span>树而不用B树是因为有的时候查询数据可能不止一条，对于B树来说，他的每一层都存有数据，可能会出现跨层访问，但是对于B<span class="token operator">+</span>树来说，他的所有数据都在叶子节点，且都在同一层，还有链表结构，只需要找到首尾就可以通过链表结构取出所有数据。    其实对于hash来说，查询单条数据确实快，但是同B树，查询多条就不行了。</code></pre><h3 id="104-spring事务的实现方式？"><a href="#104-spring事务的实现方式？" class="headerlink" title="104.spring事务的实现方式？"></a>104.spring事务的实现方式？</h3><pre class=" language-java"><code class="language-java">    编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用<span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>、<span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>、<span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>等事务管理相关的方法，这就是编程式事务管理。    基于 TransactionProxyFactoryBean的声明式事务管理    基于 <span class="token annotation punctuation">@Transactional</span> 的声明式事务管理    基于Aspectj AOP配置事务</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my-first-article</title>
      <link href="/2020/02/23/my-first-article/"/>
      <url>/2020/02/23/my-first-article/</url>
      
        <content type="html"><![CDATA[<h2 id="Java开发需要用到的技术"><a href="#Java开发需要用到的技术" class="headerlink" title="Java开发需要用到的技术"></a>Java开发需要用到的技术</h2><h3 id="开发"><a href="#开发" class="headerlink" title="开发:"></a>开发:</h3><ol><li>视图层技术–HTML,JS,AJAX,Tiles,Velocity,FreeMarker</li><li>持久层技术–MyBatis,Hibernate</li><li>Spring,Spring MVC</li><li>项目构建工具Maven</li><li>日志Log4j</li><li>版本控制git</li></ol><h3 id="数据库技术"><a href="#数据库技术" class="headerlink" title="数据库技术:"></a>数据库技术:</h3><ol><li>SQL语句</li><li>参数调优(MySQL高级)</li></ol><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统:"></a>操作系统:</h3><ol><li>熟练掌握一种Linux系统,原理,Shell命令</li></ol><h3 id="服务器技术"><a href="#服务器技术" class="headerlink" title="服务器技术:"></a>服务器技术:</h3><ol><li>熟练使用并理解一个应用服务器技术的原理(Tomcat)</li><li>熟练使用并理解一个Web服务器技术的原理(Nginx)</li></ol><h3 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术:"></a>缓存技术:</h3><ol><li>熟练使用并理解一种缓存技术(Redis,Memcache,EhCache)</li><li>熟练使用并理解一种非关系型数据库(MongoDB)</li></ol><h3 id="中间件技术"><a href="#中间件技术" class="headerlink" title="中间件技术:"></a>中间件技术:</h3><ol><li>JMS:activeMQ和Kafka(消息队列)</li><li>RPC:Dubbo</li></ol><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式:"></a>设计模式:</h3><ol><li>了解并能够使用几种最主要的设计模式(Spring的9种设计模式)(GOF 23种设计模式)</li></ol><h3 id="网络"><a href="#网络" class="headerlink" title="网络:"></a>网络:</h3><ol><li>熟练使用并理解一个网络开发技术(Netty)</li><li>熟悉http,TCP协议</li></ol><h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机:"></a>Java虚拟机:</h3><ol><li>熟悉jvm运行原理,内存分布</li><li>jvm参数调优</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/21/hello-world/"/>
      <url>/2020/02/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
